!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,t=e=>"[object Function]"===Object.prototype.toString.call(e),o=e=>{throw new Error(e)},n=e=>{console.warn(e)},r="method",s="initId",i="after",l="repeat",d="memo",c="indicators",a="hmpl",p=/(\{\{(?:.|\n|\r)*?\}\}|\{\s*\{(?:.|\n|\r)*?\}\s*\})/g,f=/([{}])|([^{}]+)/g,u=[100,101,102,103,300,301,302,303,304,305,306,307,308,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,421,422,423,424,425,426,428,429,431,451,500,501,502,503,504,505,506,507,508,510,511],h=e=>(new DOMParser).parseFromString(`<template>${e}</template>`,"text/html").childNodes[0].childNodes[0].firstChild,m=(t,r,s,i,l,d,c,a,p={},f,u,m)=>{const{mode:g,cache:y,redirect:v,get:b,referrerPolicy:N,signal:w,credentials:P,timeout:T,referrer:E,headers:j,body:O,window:I,integrity:$}=p,C={method:i.toUpperCase()};void 0!==P&&(C.credentials=P),void 0!==O&&(C.body=O),void 0!==g&&(C.mode=g),void 0!==y&&(C.cache=y),void 0!==v&&(C.redirect=v),void 0!==N&&(C.referrerPolicy=N),void 0!==$&&(C.integrity=$),void 0!==E&&(C.referrer=E);const k=void 0!==w;if(k&&(C.signal=w),void 0!==I&&(C.window=I),void 0!==p.keepalive&&n("keepalive property is not yet supported"),j)if(e(j)){const e=new Headers;for(const t in j){const[n,r]=t;if("string"==typeof r)try{e.set(n,r)}catch(e){throw e}else o("Header has no string value")}C.headers=e}else o('The "header" property does not have a value object');T&&(k?n("The signal property overwrote the AbortSignal from timeout"):C.signal=AbortSignal.timeout(T));const x=a&&!d&&s?.memo,q=e=>"rejected"===e||"number"==typeof e&&(e<200||e>299),A=e=>{c&&(u.response=e,b?.("response",e,u)),b?.("response",r)},S=(e,n=!0,r=!1)=>{if(d)f.response=e.cloneNode(!0),b?.("response",e);else{let i=[];const l=(n?e.cloneNode(!0):e).content.childNodes;if(s.nodes){const e=s.parentNode;e||o("parentNode is null");const t=[],n=s.nodes.length;for(let o=0;o<n;o++){const r=s.nodes[o];if(o===n-1)for(let o=0;o<l.length;o++){const n=l[o],s=e.insertBefore(n,r);t.push(s)}e.removeChild(r)}i=t.slice(),s.nodes=t}else{const e=t.parentNode,o=[];for(let n=0;n<l.length;n++){const r=l[n],s=e.insertBefore(r,t);o.push(s)}e.removeChild(t),i=o.slice(),s.nodes=o,s.parentNode=e}x&&r&&(s.memo.nodes=s.nodes,s.memo.isPending&&(s.memo.isPending=!1)),A(i)}};let B=!1,R=!1;const L=()=>{if(d)f.response=void 0,b?.("response",void 0);else if(s.nodes){const e=s.parentNode;e||o("parentNode is null");const t=s.nodes.length;for(let o=0;o<t;o++){const n=s.nodes[o];o===t-1&&e.insertBefore(s.comment,n),e.removeChild(n)}s.nodes=null,s.parentNode=null,c&&(u.response=void 0,b?.("response",void 0,u)),b?.("response",r)}x&&null!==s.memo.response&&(s.memo.response=null,delete s.memo.isPending,delete s.memo.nodes)},D=e=>{c?u.status!==e&&(u.status=e,b?.("status",e,u)):f.status!==e&&(f.status=e,b?.("status",e)),x&&q(e)&&(s.memo.response=null,delete s.memo.nodes),(e=>{if(m)if(x&&"pending"!==e&&q(e)&&s.memo.isPending&&(s.memo.isPending=!1),"pending"===e){const e=m.pending;void 0!==e&&(x&&(s.memo.isPending=!0),S(e))}else if("rejected"===e){const e=m.rejected;if(void 0!==e)S(e);else{const e=m.error;void 0!==e?S(e):L()}}else{const t=m[`${e}`];if(e>399)if(B=!0,void 0!==t)S(t);else{const e=m.error;void 0!==e?S(e):L()}else(e<200||e>299)&&(R=!0,void 0!==t?S(t):L())}})(e)};let H=200;D("pending"),fetch(l,C).then((e=>(H=e.status,D(H),e.ok||o(`Request error with code ${H}`),e.text()))).then((e=>{if(!R)if(q(H))L();else{if(x){const{response:t}=s.memo;if(null===t)s.memo.response=e;else{if(t===e)return void(()=>{if(s.memo.isPending){const e=s.parentNode;e||o("parentNode is null");const t=s.memo.nodes,n=s.nodes,r=n.length,i=[];for(let o=0;o<r;o++){const s=n[o];if(o===r-1)for(let o=0;o<t.length;o++){const n=t[o],r=e.insertBefore(n,s);i.push(r)}e.removeChild(s)}s.nodes=i.slice(),s.memo.isPending=!1,s.memo.nodes=i.slice()}const e=s.nodes.slice();A(e)})();s.memo.response=e,delete s.memo.nodes}}const n=(e=>{"string"!=typeof e&&o("Bad response");const t=h(e),n=t.content,r=n.querySelectorAll("script");for(let e=0;e<r.length;e++){const t=r[e];n.removeChild(t)}return t})(e);if(d)f.response=n,b?.("response",n);else{const e=[],o=n.content.childNodes;if(s)S(n,!1,!0);else{const n=t.parentNode;for(let r=0;r<o.length;r++){const s=o[r],i=n.insertBefore(s,t);c&&e.push(i)}n.removeChild(t),c&&(u.response=e,b?.("response",e,u)),b?.("response",r)}}}})).catch((e=>{throw B||(D("rejected"),m||L()),e}))},g=t=>{e(t)&&t.hasOwnProperty("id")&&t.hasOwnProperty("value")||o("Identification options error")};return{compile:(n,y={})=>{"string"!=typeof n&&o("template was not found or the type of the passed value is not string"),n||o("template empty"),e(y)||o("Options must be an object");const v=!y.hasOwnProperty(d);v||"boolean"==typeof y[d]||o(`The value of the property ${d} must be a boolean value`);const b=[],N=n.split(p).filter(Boolean),w=[];for(const e of n.matchAll(p))w.push(e.index);0===w.length&&o("Request not found");const P=e=>e=(e=e.trim()).replace(/\r?\n|\r/g,""),T=(e,t)=>{const n=JSON.parse(e);for(const e in n){const t=n[e];switch("src"!==e&&e!==r&&e!==s&&e!==i&&e!==l&&e!==c&&e!==d&&o(`Property ${e} is not processed`),e){case c:Array.isArray(t)||o(`The value of the property ${e} must be an array`);break;case s:"string"!=typeof t&&"number"!=typeof t&&o(`The value of the property ${e} must be a string`);break;case d:case l:"boolean"!=typeof t&&o(`The value of the property ${e} must be a boolean value`);break;default:"string"!=typeof t&&o(`The value of the property ${e} must be a string`)}}const a={...n,arrId:t};b.push(a)};let E=0;for(let e=0;e<N.length;e++){const t=N[e];if(w.includes(E)){const n=t.split(f).filter(Boolean);let r=-1,s="",i=!0,l=!1;for(let d=0;d<n.length;d++){const c=n[d],a="}"===c;if("{"===c)i?(i=!1,"{"!==n[d+1]&&d++):s+=c,r++;else if(a){if(-1===r&&o("Parse error"),1===r&&(l=!0),0===r){T(s,e),r--,E+=t.length;break}r--,s+=c}else l?P(c)&&o("Parse error"):s+=c}if(-1!==r){const n=e+1,i=N[n];void 0===i&&o("Parse error");const d=i.split(f).filter(Boolean);let c="";for(let a=0;a<d.length;a++){const p=d[a],f="{"===p;if("}"===p){if(-1===r&&o("Parse error"),1===r&&(l=!0),0===r){const o=[...d];E+=t.length+i.length,o.splice(0,a+1),N[n]=o.join(""),T(s+c,e),r--,e++;break}r--,c+=p}else f?(c+=p,r++):l?P(p)&&o("Parse error"):c+=p}}-1!==r&&o("Parse error")}else E+=t.length}0===b.length&&o("Request not found");for(let e=0;e<b.length;e++){const t=b[e],{arrId:o}=t,n=`\x3c!--hmpl${e}--\x3e`;N[o]=n,delete t.arrId}n=N.join("");let j=!1;const O=(e=>{const t=h(e.trim());(t.content.childNodes.length>1||1!==t.content.children.length)&&o('Template include only one node with type "Element" or "Comment"');const n=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("pre"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)n(e.childNodes.item(t))};n(t.content.childNodes[0]);let r=t.content.firstElementChild;if(!r){const e=t.content.firstChild,n=8===e?.nodeType;n?(j=n,r=e):o("Element is undefined")}return r})(n);return((n,s,c,p,f,g=!1)=>{const y=(n,s)=>{const c=n.src;if(c){const a=(n.method||"GET").toLowerCase();if(!(e=>"get"!==e&&"post"!==e&&"put"!==e&&"delete"!==e&&"patch"!==e)(a)){const r=n.after;r&&g&&o("EventTarget is undefined");const y=!n.hasOwnProperty(l);y||"boolean"==typeof n.repeat||o(`${l} has only boolean value`);const v="all"==(y||n.repeat?"all":"one"),b=!n.hasOwnProperty(d);let N=!f&&p.memo;b?N&&(r&&v||(N=!1)):r?n.memo?v?N=!0:o("memoization works in the enabled repetition mode"):N=!1:o("memoization works in the enabled repetition mode");const w=n.initId,P=n.nodeId;let T=n.indicators;if(T){const e=e=>{const{trigger:t,content:n}=e;t||o("Indicator trigger error"),n||o("Indicator content error"),-1===u.indexOf(t)&&"pending"!==t&&"rejected"!==t&&"error"!==t&&o("Indicator trigger error");const r=h(n);return{...e,content:r}},t={},n=[];for(let r=0;r<T.length;r++){const s=e(T[r]),{trigger:i}=s;-1===n.indexOf(i)?n.push(i):o("Indicator trigger must be unique"),t[`${i}`]=s.content}T=t}const E=(e,t=!1)=>{if(t){if(w){let t;for(let o=0;o<e.length;o++){const n=e[o];if(n.id===w){t=n.value;break}}return t||o("id referenced by request not found"),t}return{}}return w&&o("id referenced by request not found"),e},j=v&&r,O=(n,r,i,l,d,p=!1,f,u=!1,h,y)=>{const v=l.currentId;if(g)n||(n=s);else if(!n)if(h)n=h.el;else{let e;const{els:t}=l;for(let o=0;o<t.length;o++){const n=t[o];if(n.id===P){h=n,e=n.el;break}}e||o("Element error"),n=e}let b;g||(j||T)&&(h||o("Element error"),b=h.objNode,b||(b={id:v,nodes:null,parentNode:null,comment:n},N&&(b.memo={response:null},T&&(b.memo.isPending=!1)),h.objNode=b,l.dataObjects.push(b),l.currentId++));const w=E(r,p),O=t(w)?((e,t)=>{const o={};return void 0!==t&&(o.event=t),e({request:o})})(w,y):w;e(O)||void 0===O||o("RequestInit error"),m(n,d,b,a,c,g,u,N,O,i,f,T)};let I=O;if(r){const e=(e,t,n,r,s,i,l,d,c,a,p)=>{const f=c.querySelectorAll(n);0===f.length&&o("Selectors nodes not found");const u=v?t=>{O(e,r,s,i,c,l,a,d,p,t)}:o=>{O(e,r,s,i,c,l,a,d,p,o);for(let e=0;e<f.length;e++)f[e].removeEventListener(t,u)};for(let e=0;e<f.length;e++)f[e].addEventListener(t,u)};if(r.indexOf(":")>0){const t=r.split(":"),o=t[0],n=t.slice(1).join(":");I=(t,r,s,i,l,d=!1,c,a=!1,p)=>{e(t,o,n,r,s,i,d,a,l,c,p)}}else o(`${i} property doesn't work without EventTargets`)}else y||o(`${l} property doesn't work without ${i}`);return I}o(`${r} has only GET, POST, PUT, PATCH or DELETE values`)}else o('The "source" property are not found or empty')};let v;if(g)c[0].el=n,v=y(c[0]);else{let e=-2;const t=n=>{if(e++,8==n.nodeType){let t=n.nodeValue;if(t&&t.startsWith(a)){t=t.slice(4);const r=Number(t),s=c[r];(Number.isNaN(r)||void 0===s)&&o("Request index error"),s.el=n,s.nodeId=e}}if(n.hasChildNodes()){const e=n.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(n);const r=[];for(let e=0;e<c.length;e++){const t=c[e];r.push(y(t,n))}if(c.length>1)v=(e,t,n,s,i,l=!1)=>{e||(e=i);const d=[],c=s.els;for(let i=0;i<c.length;i++){const a=c[i],p=a.el;null===p.parentNode&&o('"parentNode" is null');const f={response:void 0};(0,r[i])(p,t,n,s,e,l,f,!0,a),d.push(f)}n.requests=d};else{const e=c[0];null===e.el.parentNode&&o('"parentNode" is null'),v=y(e,n)}}return s(v)})(O,(n=>(r={})=>{const s=O.cloneNode(!0),i={response:j?void 0:s},l={dataObjects:[],els:[],currentId:0};if(!j){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith(a)){const t={el:o,id:e};l.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(s)}return e(r)||t(r)?((n=>{const r=e(n);r||t(n)||void 0===n||o("RequestInit type error"),r&&n.get&&(t(n.get)||o("The get property has a function value"))})(r),n(void 0,r,i,l,s)):Array.isArray(r)&&((t=>{const n=[];for(let r=0;r<t.length;r++){const s=t[r];e(s)||o('options is of type "object"'),g(s);const{id:i}=s;"string"!=typeof s.id&&"number"!=typeof s.id&&o('Id must be a "string" or a "number".'),n.indexOf(i)>-1?o(`id with value "${i}" already exists`):n.push(i)}})(r),n(void 0,r,i,l,s,!0)),i}),b,y,v,j)},stringify:e=>JSON.stringify(e)}}()}));