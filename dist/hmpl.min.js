!function(e,t){"object"==typeof module&&module.exports?module.exports=t():"function"==typeof define&&define.amd?define([],t):e.hmpl=e.hmpl||t()}("undefined"!=typeof self?self:this,(function(){return function(){"use strict";const e=e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,t=e=>"[object Function]"===Object.prototype.toString.call(e),o=e=>{throw new Error(e)},n=e=>{console.warn(e)},r="method",s="initId",i="after",l="repeat",d="memo",c="indicators",a="autoBody",f="hmpl",p="formData",u={formData:!0},m={formData:!1},h=/(\{\{(?:.|\n|\r)*?\}\}|\{\s*\{(?:.|\n|\r)*?\}\s*\})/g,g=/([{}])|([^{}]+)/g,y=["src",r,s,i,l,c,d,a],v=[100,101,102,103,300,301,302,303,304,305,306,307,308,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,421,422,423,424,425,426,428,429,431,451,500,501,502,503,504,505,506,507,508,510,511],b=e=>(new DOMParser).parseFromString(`<template>${e}</template>`,"text/html").childNodes[0].childNodes[0].firstChild,N=(t,r,s,i,l,d,c,a,f={},p,u,m)=>{const{mode:h,cache:g,redirect:y,get:v,referrerPolicy:N,signal:w,credentials:P,timeout:T,referrer:E,headers:O,body:j,window:I,integrity:$}=f,k={method:i.toUpperCase()};void 0!==P&&(k.credentials=P),void 0!==j&&(k.body=j),void 0!==h&&(k.mode=h),void 0!==g&&(k.cache=g),void 0!==y&&(k.redirect=y),void 0!==N&&(k.referrerPolicy=N),void 0!==$&&(k.integrity=$),void 0!==E&&(k.referrer=E);const C=void 0!==w;if(C&&(k.signal=w),void 0!==I&&(k.window=I),void 0!==f.keepalive&&n("keepalive property is not yet supported"),O)if(e(O)){const e=new Headers;for(const t in O){const[n,r]=t;if("string"==typeof r)try{e.set(n,r)}catch(e){throw e}else o("Header has no string value")}k.headers=e}else o('The "header" property does not have a value object');T&&(C?n("The signal property overwrote the AbortSignal from timeout"):k.signal=AbortSignal.timeout(T));const x=a&&!d&&s?.memo,q=e=>"rejected"===e||"number"==typeof e&&(e<200||e>299),B=e=>{c&&(u.response=e,v?.("response",e,u)),v?.("response",r)},A=(e,n=!0,r=!1)=>{if(d)p.response=e.cloneNode(!0),v?.("response",e);else{let i=[];const l=(n?e.cloneNode(!0):e).content.childNodes;if(s.nodes){const e=s.parentNode;e||o("parentNode is null");const t=[],n=s.nodes.length;for(let o=0;o<n;o++){const r=s.nodes[o];if(o===n-1)for(let o=0;o<l.length;o++){const n=l[o],s=e.insertBefore(n,r);t.push(s)}e.removeChild(r)}i=t.slice(),s.nodes=t}else{const e=t.parentNode,o=[];for(let n=0;n<l.length;n++){const r=l[n],s=e.insertBefore(r,t);o.push(s)}e.removeChild(t),i=o.slice(),s.nodes=o,s.parentNode=e}x&&r&&(s.memo.nodes=s.nodes,s.memo.isPending&&(s.memo.isPending=!1)),B(i)}};let S=!1,D=!1;const R=()=>{if(d)p.response=void 0,v?.("response",void 0);else if(s.nodes){const e=s.parentNode;e||o("parentNode is null");const t=s.nodes.length;for(let o=0;o<t;o++){const n=s.nodes[o];o===t-1&&e.insertBefore(s.comment,n),e.removeChild(n)}s.nodes=null,s.parentNode=null,c&&(u.response=void 0,v?.("response",void 0,u)),v?.("response",r)}x&&null!==s.memo.response&&(s.memo.response=null,delete s.memo.isPending,delete s.memo.nodes)},L=e=>{c?u.status!==e&&(u.status=e,v?.("status",e,u)):p.status!==e&&(p.status=e,v?.("status",e)),x&&q(e)&&(s.memo.response=null,delete s.memo.nodes),(e=>{if(m)if(x&&"pending"!==e&&q(e)&&s.memo.isPending&&(s.memo.isPending=!1),"pending"===e){const e=m.pending;void 0!==e&&(x&&(s.memo.isPending=!0),A(e))}else if("rejected"===e){const e=m.rejected;if(void 0!==e)A(e);else{const e=m.error;void 0!==e?A(e):R()}}else{const t=m[`${e}`];if(e>399)if(S=!0,void 0!==t)A(t);else{const e=m.error;void 0!==e?A(e):R()}else(e<200||e>299)&&(D=!0,void 0!==t?A(t):R())}})(e)};let F=200;L("pending"),fetch(l,k).then((e=>(F=e.status,L(F),e.ok||o(`Request error with code ${F}`),e.text()))).then((e=>{if(!D)if(q(F))R();else{if(x){const{response:t}=s.memo;if(null===t)s.memo.response=e;else{if(t===e)return void(()=>{if(s.memo.isPending){const e=s.parentNode;e||o("parentNode is null");const t=s.memo.nodes,n=s.nodes,r=n.length,i=[];for(let o=0;o<r;o++){const s=n[o];if(o===r-1)for(let o=0;o<t.length;o++){const n=t[o],r=e.insertBefore(n,s);i.push(r)}e.removeChild(s)}s.nodes=i.slice(),s.memo.isPending=!1,s.memo.nodes=i.slice()}const e=s.nodes.slice();B(e)})();s.memo.response=e,delete s.memo.nodes}}const n=(e=>{"string"!=typeof e&&o("Bad response");const t=b(e),n=t.content,r=n.querySelectorAll("script");for(let e=0;e<r.length;e++){const t=r[e];n.removeChild(t)}return t})(e);if(d)p.response=n,v?.("response",n);else{const e=[],o=n.content.childNodes;if(s)A(n,!1,!0);else{const n=t.parentNode;for(let r=0;r<o.length;r++){const s=o[r],i=n.insertBefore(s,t);c&&e.push(i)}n.removeChild(t),c&&(u.response=e,v?.("response",e,u)),v?.("response",r)}}}})).catch((e=>{throw S||(L("rejected"),m||R()),e}))},w=t=>{const n=e(t);if("boolean"==typeof t||n||o("autoBody error"),n)for(const e in t)if(e===p)"boolean"!=typeof t[p]&&o("formData error");else o("autoBody error")},P=t=>{e(t)&&t.hasOwnProperty("id")&&t.hasOwnProperty("value")||o("Identification options error")};return{compile:(n,p={})=>{"string"!=typeof n&&o("template was not found or the type of the passed value is not string"),n||o("Template must not be a falsey value"),e(p)||o("Options must be an object");const T=!p.hasOwnProperty(d);T||"boolean"==typeof p[d]||o(`The value of the property ${d} must be a boolean value`);const E=!p.hasOwnProperty(a);E||w(p[a]);const O=[],j=n.split(h).filter(Boolean),I=[];for(const e of n.matchAll(h))I.push(e.index);0===I.length&&o("Request not found");const $=e=>e=(e=e.trim()).replace(/\r?\n|\r/g,""),k=(e,t)=>{const n=JSON.parse(e);for(const e in n){const t=n[e];switch(y.includes(e)||o(`Property ${e} is not processed`),e){case c:Array.isArray(t)||o(`The value of the property ${e} must be an array`);break;case s:"string"!=typeof t&&"number"!=typeof t&&o(`The value of the property ${e} must be a string`);break;case d:case l:"boolean"!=typeof t&&o(`The value of the property ${e} must be a boolean value`);break;case a:w(t);break;default:"string"!=typeof t&&o(`The value of the property ${e} must be a string`)}}const r={...n,arrId:t};O.push(r)};let C=0;for(let e=0;e<j.length;e++){const t=j[e];if(I.includes(C)){const n=t.split(g).filter(Boolean);let r=-1,s="",i=!0,l=!1;for(let d=0;d<n.length;d++){const c=n[d],a="}"===c;if("{"===c)i?(i=!1,"{"!==n[d+1]&&d++):s+=c,r++;else if(a){if(-1===r&&o("Parse error"),1===r&&(l=!0),0===r){k(s,e),r--,C+=t.length;break}r--,s+=c}else l?$(c)&&o("Parse error"):s+=c}if(-1!==r){const n=e+1,i=j[n];void 0===i&&o("Parse error");const d=i.split(g).filter(Boolean);let c="";for(let a=0;a<d.length;a++){const f=d[a],p="{"===f;if("}"===f){if(-1===r&&o("Parse error"),1===r&&(l=!0),0===r){const o=[...d];C+=t.length+i.length,o.splice(0,a+1),j[n]=o.join(""),k(s+c,e),r--,e++;break}r--,c+=f}else p?(c+=f,r++):l?$(f)&&o("Parse error"):c+=f}}-1!==r&&o("Parse error")}else C+=t.length}0===O.length&&o("Request not found");for(let e=0;e<O.length;e++){const t=O[e],{arrId:o}=t,n=`\x3c!--hmpl${e}--\x3e`;j[o]=n,delete t.arrId}n=j.join("");let x=!1;const q=(e=>{const t=b(e.trim());(t.content.childNodes.length>1||1!==t.content.children.length)&&o('Template include only one node with type "Element" or "Comment"');const n=e=>{switch(e.nodeType){case Node.ELEMENT_NODE:if("pre"===e.tagName)return;break;case Node.TEXT_NODE:if(!/\S/.test(e.textContent))return void e.remove()}for(let t=0;t<e.childNodes.length;t++)n(e.childNodes.item(t))};n(t.content.childNodes[0]);let r=t.content.firstElementChild;if(!r){const e=t.content.firstChild,n=8===e?.nodeType;n?(x=n,r=e):o("Element is undefined")}return r})(n);return((n,s,c,p,h,g,y=!1)=>{const P=(n,s)=>{const c=n.src;if(c){const f=(n.method||"GET").toLowerCase();if(!(e=>"get"!==e&&"post"!==e&&"put"!==e&&"delete"!==e&&"patch"!==e)(f)){const r=n.after;r&&y&&o("EventTarget is undefined");const P=!n.hasOwnProperty(l);P||"boolean"==typeof n.repeat||o(`${l} has only boolean value`);const T="all"==(P||n.repeat?"all":"one"),E=!n.hasOwnProperty(d);let O=!h&&p.memo;E?O&&(r&&T||(O=!1)):r?n.memo?T?O=!0:o("memoization works in the enabled repetition mode"):O=!1:o("memoization works in the enabled repetition mode");const j=!n.hasOwnProperty(a);let I=!g&&p.autoBody;if(j)!0===I&&(I=u),r||(I=!1);else if(r){let e=n[a];if(w(e),!0===I&&(I=u),!0===e&&(e=u),!1===e)I=!1;else{const t={...!1===I?m:I,...e};I=t}}else I=!1;const $=n.initId,k=n.nodeId;let C=n.indicators;if(C){const e=e=>{const{trigger:t,content:n}=e;t||o("Indicator trigger error"),n||o("Indicator content error"),-1===v.indexOf(t)&&"pending"!==t&&"rejected"!==t&&"error"!==t&&o("Indicator trigger error");const r=b(n);return{...e,content:r}},t={},n=[];for(let r=0;r<C.length;r++){const s=e(C[r]),{trigger:i}=s;-1===n.indexOf(i)?n.push(i):o("Indicator trigger must be unique"),t[`${i}`]=s.content}C=t}const x=(e,t=!1)=>{if(t){if($){let t;for(let o=0;o<e.length;o++){const n=e[o];if(n.id===$){t=n.value;break}}return t||o("id referenced by request not found"),t}return{}}return $&&o("id referenced by request not found"),e},q=T&&r,B=(n,r,i,l,d,a=!1,p,u=!1,m,h)=>{const g=l.currentId;if(y)n||(n=s);else if(!n)if(m)n=m.el;else{let e;const{els:t}=l;for(let o=0;o<t.length;o++){const n=t[o];if(n.id===k){m=n,e=n.el;break}}e||o("Element error"),n=e}let v;y||(q||C)&&(m||o("Element error"),v=m.objNode,v||(v={id:g,nodes:null,parentNode:null,comment:n},O&&(v.memo={response:null},C&&(v.memo.isPending=!1)),m.objNode=v,l.dataObjects.push(v),l.currentId++));let b=x(r,a);const w=t(b);if(!w&&b&&(b={...b}),I&&I.formData&&h&&!w){const{type:e,target:t}=h;"submit"===e&&t&&t instanceof HTMLFormElement&&"FORM"===t.nodeName&&(b.body=new FormData(t,h.submitter))}const P=w?((e,t)=>{const o={};return void 0!==t&&(o.event=t),e({request:o})})(b,h):b;e(P)||void 0===P||o("RequestInit error"),N(n,d,v,f,c,y,u,O,P,i,p,C)};let A=B;if(r){const e=(e,t,n,r,s,i,l,d,c,a,f)=>{const p=c.querySelectorAll(n);0===p.length&&o("Selectors nodes not found");const u=T?t=>{B(e,r,s,i,c,l,a,d,f,t)}:o=>{B(e,r,s,i,c,l,a,d,f,o);for(let e=0;e<p.length;e++)p[e].removeEventListener(t,u)};for(let e=0;e<p.length;e++)p[e].addEventListener(t,u)};if(r.indexOf(":")>0){const t=r.split(":"),o=t[0],n=t.slice(1).join(":");A=(t,r,s,i,l,d=!1,c,a=!1,f)=>{e(t,o,n,r,s,i,d,a,l,c,f)}}else o(`${i} property doesn't work without EventTargets`)}else P||o(`${l} property doesn't work without ${i}`);return A}o(`${r} has only GET, POST, PUT, PATCH or DELETE values`)}else o('The "source" property are not found or empty')};let T;if(y)c[0].el=n,T=P(c[0]);else{let e=-2;const t=n=>{if(e++,8==n.nodeType){let t=n.nodeValue;if(t&&t.startsWith(f)){t=t.slice(4);const r=Number(t),s=c[r];(Number.isNaN(r)||void 0===s)&&o("Request index error"),s.el=n,s.nodeId=e}}if(n.hasChildNodes()){const e=n.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(n);const r=[];for(let e=0;e<c.length;e++){const t=c[e];r.push(P(t,n))}if(c.length>1)T=(e,t,n,s,i,l=!1)=>{e||(e=i);const d=[],c=s.els;for(let i=0;i<c.length;i++){const a=c[i],f=a.el;null===f.parentNode&&o('"parentNode" is null');const p={response:void 0};(0,r[i])(f,t,n,s,e,l,p,!0,a),d.push(p)}n.requests=d};else{const e=c[0];null===e.el.parentNode&&o('"parentNode" is null'),T=P(e,n)}}return s(T)})(q,(n=>(r={})=>{const s=q.cloneNode(!0),i={response:x?void 0:s},l={dataObjects:[],els:[],currentId:0};if(!x){let e=-2;const t=o=>{if(e++,8==o.nodeType){const t=o.nodeValue;if(t&&t.startsWith(f)){const t={el:o,id:e};l.els.push(t)}}if(o.hasChildNodes()){const e=o.childNodes;for(let o=0;o<e.length;o++)t(e[o])}};t(s)}return e(r)||t(r)?((n=>{const r=e(n);r||t(n)||void 0===n||o("RequestInit type error"),r&&n.get&&(t(n.get)||o("The get property has a function value"))})(r),n(void 0,r,i,l,s)):Array.isArray(r)&&((t=>{const n=[];for(let r=0;r<t.length;r++){const s=t[r];e(s)||o('options is of type "object"'),P(s);const{id:i}=s;"string"!=typeof s.id&&"number"!=typeof s.id&&o('Id must be a "string" or a "number".'),n.indexOf(i)>-1?o(`id with value "${i}" already exists`):n.push(i)}})(r),n(void 0,r,i,l,s,!0)),i}),O,p,T,E,x)},stringify:e=>JSON.stringify(e)}}()}));